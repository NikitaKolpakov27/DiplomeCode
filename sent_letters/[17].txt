=========ЗАГОЛОВКИ ПИСЬМА==========
FROM: ('=?UTF-8?B?0JrQvtC70L/QsNC60L7QsiDQnS7QoS4=?=', 'nik.kolpakov@inbox.ru')
TO: =?UTF-8?B?0JzQuNGF0LDQuNC7INCU0YDRjtGH0LXQvdC60L4=?= <m_dryuchenko@mail.ru>
DATE: Mon, 29 Nov 2021 17:10:30 +0300
SUBJECT: =?UTF-8?B?UmU6INC60LzQt9C4ICg0KQ==?=
MESSAGE_ID: <1638195030.836656109@f397.i.mail.ru>


=====ТЕЛО ПИСЬМА===========
Здравствуйте. Да, в 5-ой задаче автоматизированно не получается исходный текст, но в том тексте несложно заметить знакомые слова, и уже по ним менять буквы в словаре.
 
Хотелось бы немного поподробнее рассказать про проблему с выводом хэшей.
Я слегка дописал код, исходя из Ваших подсказок (возможно, я неправильно всё разместил, но проблема всё равно осталась)
Для первых 5 сообщениях хэши выглядят так:
 
 
А вот, начиная с 6-го, так:
 
 
До поправок вывод был примерно таким же. 
>Понедельник, 29 ноября 2021, 15:33 +03:00 от Михаил Дрюченко <m_dryuchenko@mail.ru>:
> 
>Никита, добрый день!
> 
>5-я задача принята. Как я понимаю реализация предполагает дополнительную ручную коррекцию таблиц замен? 
> 
>По 4-й:
>1. Согласно моему варианту (2-ой), я написал msg = reinterpret_cast(old_msg ^ IV), только после этой строчки вылезает ошибка -1073741819. Возможно, нужно расписать операцию xor по-другому, но как?
>Не ясно для чего здесь  reinterpret_cast. Этот оператор обычно  используется для преобразования указателей одного типа в другой
> 
>char* msg; ...
>unsigned int old_msg = reinterpret_cast<unsigned int>(msg); 
>// что бы не получить неопределенного поведения можно использовать функции memcpy
>// для записи содержимого msg в old_msg (число записываемых байт определяем по размеру old_msg)
>memcpy(&old_msg, &msg[0], sizeof(old_msg));
> 
>msg = reinterpret_cast<char *>(old_msg ^ IV);   // (!) здесь IV имеет тип unsigned long long — 64бита, а old_msg м.б. 32-х битным -->  повышающее приведение для old_msg в XOR, и что запишется в msg ?
>// аналогично можно явно записать результат xor в msg, но обратите внимание на размерность msg,
>// он д.б. не менее 8 байт (!) иначе получите ошибку переполнения
>auto val = old_msg ^ IV;
>memcpy(&msg[0], &val, sizeof(val));
> 
>2. Не совсем уверен насчёт строчки IV^=mes[i].size(). Если это неправильно, то как нужно изменять значение IV в цикле?
>Данная строка не корректна. Вектор инициализации должен обновлять свое значение согласно схеме
>Здесь вектор инициализации это h_ i-1 . Промежуточное значения хеша на i-й итерации (для i-го блока открытого текста) получается как:
>hi = E  h_i-1 (m_i ^ h_i-1) ^ h_i-1 ^ mi
>Рассчитав его обновляем вектор инициализации и переходим к следующей итерации.
>Результирующий хеш — это h_n, где n — число блоков, на которые разбивается исходное сообщение для алгоритма хеширования.
> 
>3. Почему-то некоторые хэши читаются неправильно. Особенно это касается хэшей под номерами 8 и 12 (при выводе на консоль не печатаются Hash #8 и Hash#12, а у хэш №8 почему-то состоит почти из всего основного текста).
>Хеши — это последовательности байт фиксированной длины. Не очень понятно про чтение хешей? Если они сохраняются в файлы и после считываются из файлов, то сами файлы необходимо открывать в бинарном режиме. По коду в комментариях вроде стоят флаги «rb».
> 
>4. Есть ещё вопрос по поводу функции findCollisions(). По её логике должна выводится map, состоящая из пары различных сообщений, у которых одинаковый хэш. Ежели map пустая, то ничего не выводится. В моём варианте как раз пустая, но почему-то выполняется другое условие (странно то, что отладчик показал, что в map реально ничего нет, и должно выполняться нужное условие).
>В принципе подобная логика допустима, но обратите внимание на типы данных, используемые для представления данных:
>в hashAlgorithm:
>vector<string> hashVector;
>char* new_msg...
>…
>hashVector.push_back(new_msg);
>При совместном использовании символьных массивов (строк в стиле Си) и stl-строк необходимо быть предельно аккуратным (имею ввиду нулевые байты, которые являются признаком конца строки для char*, но 
>допустимы в std::string).
> 
>В дополнение могу порекомендовать использовать менее накладный вариант передачи параметров в функцию:
>void findCollisions(const vector<string>& hashes, const vector<string>& messages)
> 
>Возможно по 4-ю задачу разберем на паре, т.к. пока она у всех вызывает наибольшие трудности.
> 
>-- 
>С уважением,
>Дрюченко Михаил
 
=====ТЕЛО ПИСЬМА===========
Здравствуйте. Да, в 5-ой задаче автоматизированно не получается исходный текст, но в том тексте несложно заметить знакомые слова, и уже по ним менять буквы в словаре.
 
Хотелось бы немного поподробнее рассказать про проблему с выводом хэшей.
Я слегка дописал код, исходя из Ваших подсказок (возможно, я неправильно всё разместил, но проблема всё равно осталась)
Для первых 5 сообщениях хэши выглядят так:
 
 
А вот, начиная с 6-го, так:
 
 
До поправок вывод был примерно таким же. 
>Понедельник, 29 ноября 2021, 15:33 +03:00 от Михаил Дрюченко <m_dryuchenko@mail.ru>:
> 
>Никита, добрый день!
> 
>5-я задача принята. Как я понимаю реализация предполагает дополнительную ручную коррекцию таблиц замен? 
> 
>По 4-й:
>1. Согласно моему варианту (2-ой), я написал msg = reinterpret_cast(old_msg ^ IV), только после этой строчки вылезает ошибка -1073741819. Возможно, нужно расписать операцию xor по-другому, но как?
>Не ясно для чего здесь  reinterpret_cast. Этот оператор обычно  используется для преобразования указателей одного типа в другой
> 
>char* msg; ...
>unsigned int old_msg = reinterpret_cast<unsigned int>(msg); 
>// что бы не получить неопределенного поведения можно использовать функции memcpy
>// для записи содержимого msg в old_msg (число записываемых байт определяем по размеру old_msg)
>memcpy(&old_msg, &msg[0], sizeof(old_msg));
> 
>msg = reinterpret_cast<char *>(old_msg ^ IV);   // (!) здесь IV имеет тип unsigned long long — 64бита, а old_msg м.б. 32-х битным -->  повышающее приведение для old_msg в XOR, и что запишется в msg ?
>// аналогично можно явно записать результат xor в msg, но обратите внимание на размерность msg,
>// он д.б. не менее 8 байт (!) иначе получите ошибку переполнения
>auto val = old_msg ^ IV;
>memcpy(&msg[0], &val, sizeof(val));
> 
>2. Не совсем уверен насчёт строчки IV^=mes[i].size(). Если это неправильно, то как нужно изменять значение IV в цикле?
>Данная строка не корректна. Вектор инициализации должен обновлять свое значение согласно схеме
>Здесь вектор инициализации это h_ i-1 . Промежуточное значения хеша на i-й итерации (для i-го блока открытого текста) получается как:
>hi = E  h_i-1 (m_i ^ h_i-1) ^ h_i-1 ^ mi
>Рассчитав его обновляем вектор инициализации и переходим к следующей итерации.
>Результирующий хеш — это h_n, где n — число блоков, на которые разбивается исходное сообщение для алгоритма хеширования.
> 
>3. Почему-то некоторые хэши читаются неправильно. Особенно это касается хэшей под номерами 8 и 12 (при выводе на консоль не печатаются Hash #8 и Hash#12, а у хэш №8 почему-то состоит почти из всего основного текста).
>Хеши — это последовательности байт фиксированной длины. Не очень понятно про чтение хешей? Если они сохраняются в файлы и после считываются из файлов, то сами файлы необходимо открывать в бинарном режиме. По коду в комментариях вроде стоят флаги «rb».
> 
>4. Есть ещё вопрос по поводу функции findCollisions(). По её логике должна выводится map, состоящая из пары различных сообщений, у которых одинаковый хэш. Ежели map пустая, то ничего не выводится. В моём варианте как раз пустая, но почему-то выполняется другое условие (странно то, что отладчик показал, что в map реально ничего нет, и должно выполняться нужное условие).
>В принципе подобная логика допустима, но обратите внимание на типы данных, используемые для представления данных:
>в hashAlgorithm:
>vector<string> hashVector;
>char* new_msg...
>…
>hashVector.push_back(new_msg);
>При совместном использовании символьных массивов (строк в стиле Си) и stl-строк необходимо быть предельно аккуратным (имею ввиду нулевые байты, которые являются признаком конца строки для char*, но 
>допустимы в std::string).
> 
>В дополнение могу порекомендовать использовать менее накладный вариант передачи параметров в функцию:
>void findCollisions(const vector<string>& hashes, const vector<string>& messages)
> 
>Возможно по 4-ю задачу разберем на паре, т.к. пока она у всех вызывает наибольшие трудности.
> 
>-- 
>С уважением,
>Дрюченко Михаил
 'NoneType' object has no attribute 'decode'